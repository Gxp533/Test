# 后缀数组



```c++
void get_sa()
{
	/*
	sa[i]=j表示排名为i的后缀下标是j 
	y[i]=j表示第二个关键字排位为i的后缀，下标是从j开始的 
	x[i]=j即rk数组表示从i开始的后缀的排名是j 
	c[i]=j表示排名为i的后缀有j个 
	x[y[i]]=x[j]=k表示第二个关键字排名为i即从第j个位置开始的后缀第一个关键字排名是k
	c[x[y[i]]]=c[x[j]]=c[k]=z表示第二个关键字排名为i即从第j个位置开始的后缀第一个关键字排名k的后缀共有多少个 
	第一个关键字相同（即在同一个桶里）就按第二个关键字排序（从大到小） 
	 
	*/ 
	for(int i=1;i<=n;i++)
		++c[x[i]=s[i]];
	for(int i=2;i<=m;i++)
		c[i]+=c[i-1];//桶排序的技巧，求前缀和能得到关键字对应的最高排名 
	for(int i=n;i>=1;i--)//此时的第二关键字就是i 
		sa[c[x[i]]--]=i;//倒序 
	for(int k=1;k<=n;k<<=1)
	{
		/*
			根据sa求出第二关键字
			1越界的不存在第二关键字在最前面
			2没有越界的就能作为sa[i]-k的关键字 
		*/
		int num=0;
		for(int i=n-k+1;i<=n;i++)
			y[++num]=i;
		for(int i=1;i<=n;i++)
			if(sa[i]>k)
				y[++num]=sa[i]-k;
		/*
			根据现在的关键字进行排序 
			1桶清零
			2桶更新
			3通排序 
		*/
		for(int i=1;i<=m;i++)
			c[i]=0;
		for(int i=1;i<=n;i++)
			c[x[i]]++;
		for(int i=2;i<=m;i++)
			c[i]+=c[i-1];
		for(int i=n;i>=1;i--)
			sa[c[x[y[i]]]--]=y[i];
		//更新x要用到旧的，就可以先存入y中  
		swap(x,y);
		x[sa[1]]=1;//体现了sa和x是互逆的 
		num=1;
		for(int i=2;i<=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
		//如果两关键字相同就并列，否则就排在下一位 
		if(num==n)
			break;
		m=num;
	}
	return ;
}
void get_height()
{
	/*
	height[i]数组为lcp(suff(rk[i]),suff(rk[i-1]))两个排名相邻后缀的最长前缀 
	令h[i]=height[rk[i]],去求解h数组的最长前缀，而h数组具有如下性质：
			h[i]>=h[i-1]+k
	能减少运算 
	*/
	int k=0;
	for(int i=1;i<=n;i++)
	{
		if(x[i]==1)
			continue;
		if(k)
			k--;//h[i]>=h[i-1]+k;
		int j=sa[x[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])
			k++;
		height[x[i]]=k;
	}
}
```

## 应用

主要是对height数组的应用

1. 两个后缀的最长公共子串

   height数组的定义：lcp(i,j)=min{height[rk[i]-rk[j]]}

2. 两个字符串的最长公共子串

   将两字符串拼接即可转化为上述问题，拼接时，用不在字符集里的字符进行连接

3. 可重叠最长重复子串

   贪心的考虑，排名相近的两子串的最长前缀一定会是最优的，所以该问题就是height的最大值。

4. 最少出现k次可重叠最长子串

   height数组的大于mid值的区间长度大于k

   二分转化为判断性问题，是否存在长度为mid的重复出现k次的区间。

5. 不可重叠最长重复子串

   height数组的区间内的值都大于k

   二分转化为判断性问题，是否存在长度为k的不重叠重复数组。先考虑长度为k的可重叠重复数组，只要一个区间的height值均大于

   k，说明这个区间中的前缀均大于k。同时记录该区间中的下标的最大值m1和最小值m2，只要m1-m2>k就能保证不重叠。

6. 不同子串的个数

   按照排名从小到大遍历height数组，对于每一个后缀，对答案的贡献为:n-sa[i]+1。但是与上一个排名的后缀有重复部分为：

   height[i]。所以不同子串的个数为：n-sa[i]+1-height[i]。

7. 字符串匹配

   利用sa的单调性，sa数组存的是字典序从小到大的对应下标，在该数组上二分即可查找答案

   

